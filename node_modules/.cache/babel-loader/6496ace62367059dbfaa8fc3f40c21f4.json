{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar utils = require('web3-utils');\n\nvar Iban = require('web3-eth-iban');\n/**\n * Will format the given storage key array values to hex strings.\n *\n * @method inputStorageKeysFormatter\n *\n * @param {Array<Number|String|BN|BigNumber>} keys\n *\n * @returns {Array<String>}\n */\n\n\nvar inputStorageKeysFormatter = function (keys) {\n  return keys.map(utils.numberToHex);\n};\n/**\n * Will format the given proof response from the node.\n *\n * @method outputProofFormatter\n *\n * @param {object} proof\n *\n * @returns {object}\n */\n\n\nvar outputProofFormatter = function (proof) {\n  proof.address = utils.toChecksumAddress(proof.address);\n  proof.nonce = utils.hexToNumberString(proof.nonce);\n  proof.balance = utils.hexToNumberString(proof.balance);\n  return proof;\n};\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n *\n * @param {String|Number|BigNumber|BN} number\n *\n * @returns {BN} object\n */\n\n\nvar outputBigNumberFormatter = function (number) {\n  return utils.toBN(number).toString(10);\n};\n/**\n * Returns true if the given blockNumber is 'latest', 'pending', or 'earliest.\n *\n * @method isPredefinedBlockNumber\n *\n * @param {String} blockNumber\n *\n * @returns {Boolean}\n */\n\n\nvar isPredefinedBlockNumber = function (blockNumber) {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\n/**\n * Returns the given block number as hex string or does return the defaultBlock property of the current module\n *\n * @method inputDefaultBlockNumberFormatter\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\n\n\nvar inputDefaultBlockNumberFormatter = function (blockNumber) {\n  if (this && (blockNumber === undefined || blockNumber === null)) {\n    return inputBlockNumberFormatter(this.defaultBlock);\n  }\n\n  return inputBlockNumberFormatter(blockNumber);\n};\n/**\n * Returns the given block number as hex string or the predefined block number 'latest', 'pending', 'earliest', 'genesis'\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\n\n\nvar inputBlockNumberFormatter = function (blockNumber) {\n  if (blockNumber === undefined) {\n    return undefined;\n  }\n\n  if (isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n\n  if (blockNumber === 'genesis') {\n    return '0x0';\n  }\n\n  return utils.isHexStrict(blockNumber) ? _.isString(blockNumber) ? blockNumber.toLowerCase() : blockNumber : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nvar _txInputFormatter = function (options) {\n  if (options.to) {\n    // it might be contract creation\n    options.to = inputAddressFormatter(options.to);\n  }\n\n  if (options.data && options.input) {\n    throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n  }\n\n  if (!options.data && options.input) {\n    options.data = options.input;\n    delete options.input;\n  }\n\n  if (options.data && !options.data.startsWith('0x')) {\n    options.data = '0x' + options.data;\n  }\n\n  if (options.data && !utils.isHex(options.data)) {\n    throw new Error('The data field must be HEX encoded data.');\n  } // allow both\n\n\n  if (options.gas || options.gasLimit) {\n    options.gas = options.gas || options.gasLimit;\n  }\n\n  ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {\n    return options[key] !== undefined;\n  }).forEach(function (key) {\n    options[key] = utils.numberToHex(options[key]);\n  });\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\n\n\nvar inputCallFormatter = function (options) {\n  options = _txInputFormatter(options);\n  var from = options.from || (this ? this.defaultAccount : null);\n\n  if (from) {\n    options.from = inputAddressFormatter(from);\n  }\n\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\n\n\nvar inputTransactionFormatter = function (options) {\n  options = _txInputFormatter(options); // check from, only if not number, or object\n\n  if (!_.isNumber(options.from) && !_.isObject(options.from)) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n\n    if (!options.from && !_.isNumber(options.from)) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n\n    options.from = inputAddressFormatter(options.from);\n  }\n\n  return options;\n};\n/**\n * Hex encodes the data passed to eth_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\n\n\nvar inputSignFormatter = function (data) {\n  return utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\n\n\nvar outputTransactionFormatter = function (tx) {\n  if (tx.blockNumber !== null) tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n  if (tx.transactionIndex !== null) tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n  tx.nonce = utils.hexToNumber(tx.nonce);\n  tx.gas = utils.hexToNumber(tx.gas);\n  tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n  tx.value = outputBigNumberFormatter(tx.value);\n\n  if (tx.to && utils.isAddress(tx.to)) {\n    // tx.to could be `0x0` or `null` while contract creation\n    tx.to = utils.toChecksumAddress(tx.to);\n  } else {\n    tx.to = null; // set to `null` if invalid address\n  }\n\n  if (tx.from) {\n    tx.from = utils.toChecksumAddress(tx.from);\n  }\n\n  return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\n\n\nvar outputTransactionReceiptFormatter = function (receipt) {\n  if (typeof receipt !== 'object') {\n    throw new Error('Received receipt is invalid: ' + receipt);\n  }\n\n  if (receipt.blockNumber !== null) receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n  if (receipt.transactionIndex !== null) receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n  receipt.cumulativeGasUsed = utils.hexToNumber(receipt.cumulativeGasUsed);\n  receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n\n  if (_.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n\n  if (receipt.contractAddress) {\n    receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n  }\n\n  if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n    receipt.status = Boolean(parseInt(receipt.status));\n  }\n\n  return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\n\n\nvar outputBlockFormatter = function (block) {\n  // transform to number\n  block.gasLimit = utils.hexToNumber(block.gasLimit);\n  block.gasUsed = utils.hexToNumber(block.gasUsed);\n  block.size = utils.hexToNumber(block.size);\n  block.timestamp = utils.hexToNumber(block.timestamp);\n  if (block.number !== null) block.number = utils.hexToNumber(block.number);\n  if (block.difficulty) block.difficulty = outputBigNumberFormatter(block.difficulty);\n  if (block.totalDifficulty) block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n\n  if (_.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (!_.isString(item)) return outputTransactionFormatter(item);\n    });\n  }\n\n  if (block.miner) block.miner = utils.toChecksumAddress(block.miner);\n  return block;\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nvar inputLogFormatter = function (options) {\n  var toTopic = function (value) {\n    if (value === null || typeof value === 'undefined') return null;\n    value = String(value);\n    if (value.indexOf('0x') === 0) return value;else return utils.fromUtf8(value);\n  };\n\n  if (options === undefined) options = {}; // If options !== undefined, don't blow out existing data\n\n  if (options.fromBlock === undefined) options = { ...options,\n    fromBlock: 'latest'\n  };\n  if (options.fromBlock || options.fromBlock === 0) options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n  if (options.toBlock || options.toBlock === 0) options.toBlock = inputBlockNumberFormatter(options.toBlock); // make sure topics, get converted to hex\n\n  options.topics = options.topics || [];\n  options.topics = options.topics.map(function (topic) {\n    return _.isArray(topic) ? topic.map(toTopic) : toTopic(topic);\n  });\n  toTopic = null;\n\n  if (options.address) {\n    options.address = _.isArray(options.address) ? options.address.map(function (addr) {\n      return inputAddressFormatter(addr);\n    }) : inputAddressFormatter(options.address);\n  }\n\n  return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\n\n\nvar outputLogFormatter = function (log) {\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n    log.id = 'log_' + shaId.replace('0x', '').substr(0, 8);\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== null) log.blockNumber = utils.hexToNumber(log.blockNumber);\n  if (log.transactionIndex !== null) log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n  if (log.logIndex !== null) log.logIndex = utils.hexToNumber(log.logIndex);\n\n  if (log.address) {\n    log.address = utils.toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\n\n\nvar inputPostFormatter = function (post) {\n  // post.payload = utils.toHex(post.payload);\n  if (post.ttl) post.ttl = utils.numberToHex(post.ttl);\n  if (post.workToProve) post.workToProve = utils.numberToHex(post.workToProve);\n  if (post.priority) post.priority = utils.numberToHex(post.priority); // fallback\n\n  if (!_.isArray(post.topics)) {\n    post.topics = post.topics ? [post.topics] : [];\n  } // format the following options\n\n\n  post.topics = post.topics.map(function (topic) {\n    // convert only if not hex\n    return topic.indexOf('0x') === 0 ? topic : utils.fromUtf8(topic);\n  });\n  return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\n\n\nvar outputPostFormatter = function (post) {\n  post.expiry = utils.hexToNumber(post.expiry);\n  post.sent = utils.hexToNumber(post.sent);\n  post.ttl = utils.hexToNumber(post.ttl);\n  post.workProved = utils.hexToNumber(post.workProved); // post.payloadRaw = post.payload;\n  // post.payload = utils.hexToAscii(post.payload);\n  // if (utils.isJson(post.payload)) {\n  //     post.payload = JSON.parse(post.payload);\n  // }\n  // format the following options\n\n  if (!post.topics) {\n    post.topics = [];\n  }\n\n  post.topics = post.topics.map(function (topic) {\n    return utils.toUtf8(topic);\n  });\n  return post;\n};\n\nvar inputAddressFormatter = function (address) {\n  var iban = new Iban(address);\n\n  if (iban.isValid() && iban.isDirect()) {\n    return iban.toAddress().toLowerCase();\n  } else if (utils.isAddress(address)) {\n    return '0x' + address.toLowerCase().replace('0x', '');\n  }\n\n  throw new Error(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n};\n\nvar outputSyncingFormatter = function (result) {\n  result.startingBlock = utils.hexToNumber(result.startingBlock);\n  result.currentBlock = utils.hexToNumber(result.currentBlock);\n  result.highestBlock = utils.hexToNumber(result.highestBlock);\n\n  if (result.knownStates) {\n    result.knownStates = utils.hexToNumber(result.knownStates);\n    result.pulledStates = utils.hexToNumber(result.pulledStates);\n  }\n\n  return result;\n};\n\nmodule.exports = {\n  inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n  inputBlockNumberFormatter: inputBlockNumberFormatter,\n  inputCallFormatter: inputCallFormatter,\n  inputTransactionFormatter: inputTransactionFormatter,\n  inputAddressFormatter: inputAddressFormatter,\n  inputPostFormatter: inputPostFormatter,\n  inputLogFormatter: inputLogFormatter,\n  inputSignFormatter: inputSignFormatter,\n  inputStorageKeysFormatter: inputStorageKeysFormatter,\n  outputProofFormatter: outputProofFormatter,\n  outputBigNumberFormatter: outputBigNumberFormatter,\n  outputTransactionFormatter: outputTransactionFormatter,\n  outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n  outputBlockFormatter: outputBlockFormatter,\n  outputLogFormatter: outputLogFormatter,\n  outputPostFormatter: outputPostFormatter,\n  outputSyncingFormatter: outputSyncingFormatter\n};","map":null,"metadata":{},"sourceType":"script"}