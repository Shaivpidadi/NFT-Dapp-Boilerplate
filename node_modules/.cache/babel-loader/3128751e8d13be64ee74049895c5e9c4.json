{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\");\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */\n\n\nfunction isBloom(bloom) {\n  if (typeof bloom !== 'string') {\n    return false;\n  }\n\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isBloom = isBloom;\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */\n\nfunction isInBloom(bloom, value) {\n  if (typeof value === 'object' && value.constructor === Uint8Array) {\n    value = utils_1.bytesToHex(value);\n  }\n\n  const hash = utils_1.keccak256(value).replace('0x', '');\n\n  for (let i = 0; i < 12; i += 4) {\n    // calculate bit position in bloom filter that must be active\n    const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047; // test if bitpos in bloom is active\n\n    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n    const offset = 1 << bitpos % 4;\n\n    if ((code & offset) !== offset) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isInBloom = isInBloom;\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */\n\nfunction codePointToInt(codePoint) {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n\n  throw new Error('invalid bloom');\n}\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */\n\n\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isAddress(ethereumAddress)) {\n    throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n  } // you have to pad the ethereum address to 32 bytes\n  // else the bloom filter does not work\n  // this is only if your matching the USERS\n  // ethereum address. Contract address do not need this\n  // hence why we have 2 methods\n  // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n\n\n  const address = utils_1.padLeft(ethereumAddress, 64);\n  return isInBloom(bloom, address);\n}\n\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */\n\nfunction isContractAddressInBloom(bloom, contractAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isAddress(contractAddress)) {\n    throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n  }\n\n  return isInBloom(bloom, contractAddress);\n}\n\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */\n\nfunction isTopicInBloom(bloom, topic) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isTopic(topic)) {\n    throw new Error('Invalid topic');\n  }\n\n  return isInBloom(bloom, topic);\n}\n\nexports.isTopicInBloom = isTopicInBloom;\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */\n\nfunction isTopic(topic) {\n  if (typeof topic !== 'string') {\n    return false;\n  }\n\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isTopic = isTopic;\n/**\r\n * Is valid address\r\n * @param address The address\r\n */\n\nfunction isAddress(address) {\n  if (typeof address !== 'string') {\n    return false;\n  }\n\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    return true;\n  }\n\n  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isAddress = isAddress;","map":null,"metadata":{},"sourceType":"script"}